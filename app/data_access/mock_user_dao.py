from typing import Annotated

from fastapi import HTTPException, status
from fastapi.security import OAuth2PasswordBearer

from app.data_access.model.user_model import UserInDB

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "email": "johndoe@example.com",
        "hashed_password": "fake-hashed-secret",
        "is_adviser": False,
    },
    "alice": {
        "username": "alice",
        "email": "alice@example.com",
        "hashed_password": "fake-hashed-secret-2",
        "is_adviser": True,
    },
}

# replace "token" with '/token' endpoint, this is where a client should obtain a token from.
# this is the endpoint that the client will send the username and password to, and if they are valid,
# the client will receive a token in return.
# this token will be used to authenticate the client in future requests.
# the client will send the token in the Authorization header of the request.
# the token is a random string that is generated by the server and is unique to the user.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


# this method is used to get a user from the db
# method should be able to get a user from the db based on the username that is passed in
# if the user exists, the method should return the user, otherwise it should return None.
# here, we are mocking the db with a dictionary
def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


# this method is used to verify the token.
# method should be able to evaluate a token sent by a client and check in the db to see if
# an actual user exists with the username that is encoded in the token. If the user exists,
# the method should return the user, otherwise it should return None.
# here, we are mocking the token with just by the username
def fake_decode_token(token):
    user = get_user(fake_users_db, token)
    return user


# this method is used to get the current user.
# method should be able to get the current user based on the token that is passed in.
# if the token is valid, the method should return the user, otherwise it should raise an exception.
# here, we are mocking the token with just by the username
# in reality, the token will be a random string that is generated by the server and is unique to the user.
async def get_current_user(token: Annotated[str, oauth2_scheme]):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user


@app.post("/token")
async def login(form_data):